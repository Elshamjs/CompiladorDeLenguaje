Global:
{
    Entero aa;
    Entero int=10;
    Entero eint=-10;
    Decimal float= 0.5;
    Decimal efloat=-0.5;
    Binario bool= Falso; 
    Caracter char= 'A';
    Caracter[] buffer= Caracter[100];
    Entero[] intarray = Entero[100];
    Decimal[] floatarray= Decimal[100];
    Binario[] boolarray=  Binario[100]; 
    Caracter[][] bibuffer=Caracter[10][10];
    Entero[][] biintarray=Entero[10][10];
    Decimal[][] bifloatarray=Decimal[10][10];
    Binario[][] biboolarray=Binario[10][10];
    Caracter[] hola= "Hola Mundo"; 
}
        
Funcion Entero contarUnidadesDosDigitos(Entero num)
{
    Entero aux;
    $aux= #modulo(num, 10.7); 
    Retorna $aux;
}

Codigo:
{
    Entero numero_usuario;
    Si(a Y b) Hace{} Sino{}
    Si(a O b) Hace{} Sino{}
    Entero unidades;
    #imprimir_holamundo();
    #Mostrar("Escribe un numero de dos digitos: 0.12");
    #Capturar($numero_usuario);
    $unidades= #contarUnidadesDosDigitos($numero_usuario);
    Mostrar(unidades);

    \~ Si() Hace:
    {

    } 
    Sino
    {
        
    } ~\ 
    \~ Mientras(a < b) Hace: {} ~\
    \~ Para(Entero var=1 Hasta 10) Hace {} ~\
}

Funcion Nulo imprimir_holamundo()
{
    $buffer= "Hola Mundo\n";
    $num= num2;  
    $num= ¿num1 + num2?; 
    Mostrar($buffer);
    Retorna Nulo;
}

Funcion Entero modulo(Entero num1, Entero num2)
{
    Retorna ¿¿$num1 + $num ? + $num ?;
}





        _______________________________________________________







Global:
{
    Entero aa;
    Entero int=10;
    Entero eint=-10;
    Decimal float= 0.5;
    Decimal efloat=-0.5;
    Binario bool= Falso; 
    Caracter char= 'A';
    Caracter[] buffer= Caracter[100];
    Entero[] intarray = Entero[100];
    Decimal[] floatarray= Decimal[100];
    Binario[] boolarray=  Binario[100]; 
    Caracter[][] bibuffer=Caracter[10][10];
    Entero[][] biintarray=Entero[10][10];
    Decimal[][] bifloatarray=Decimal[10][10];
    Binario[][] biboolarray=Binario[10][10];
    Caracter[] hola= "Hola Mundo"; 
}
Codigo:
{
    $hola[0]='X';
    #Mostrar(hola);
    #SaltoLinea();
    #Mostrar(int);
    #SaltoLinea();
    #Mostrar(eint);
    #SaltoLinea();
    #Mostrar(float);
    #SaltoLinea();
    #Mostrar(efloat);
    #SaltoLinea();
    #Mostrar(bool);
    #SaltoLinea();
    #Mostrar(char);
    #SaltoLinea();
    #Mostrar("_______________________________________");
    #SaltoLinea();
    $bibuffer[0][0]= 'X';
    #MostrarLn(bibuffer[0][0]);

    $biintarray[0][0]= 100;
    #MostrarLn(biintarray[0][0]);

    $bifloatarray[0][0]= -0.678;
    #MostrarLn(bifloatarray[0][0]);

    $biboolarray[0][0]= Verdadero;
    #MostrarLn(biboolarray[0][0]);
}



_______________________________________________

Global:
{
    Entero aa;
    Entero int=10;
    Entero eint=-10;
    Decimal float= 0.5;
    Decimal efloat=-0.5;
    Binario bool= Falso; 
    Caracter char= 'A';
    Caracter[] buffer= Caracter[100];
    Entero[] intarray = Entero[100];
    Decimal[] floatarray= Decimal[100];
    Binario[] boolarray=  Binario[100]; 
    Caracter[][] bibuffer=Caracter[10][10];
    Entero[][] biintarray=Entero[10][10];
    Decimal[][] bifloatarray=Decimal[10][10];
    Binario[][] biboolarray=Binario[10][10];
    Caracter[] hola= "Hola Mundo"; 
}
Codigo:
{
    #Mostrar("El valor anterior es => ");
    #Mostrar(int);
    #SaltoLinea();
    #Mostrar("Escribe el nuevo valor => ");
    #Capturar(int);
    #SaltoLinea();
    #Mostrar("El nuevo valor es => ");
    #Mostrar(int);
    #SaltoLinea();
}

______________________________________________________________


Global:
{
    Entero aa;
    Entero int=10;
    Entero eint=-10;
    Decimal float= 0.5;
    Decimal efloat=-0.5;
    Binario bool= Falso; 
    Caracter char= 'A';
    Caracter[] buffer= Caracter[100];
    Entero[] intarray = Entero[100];
    Decimal[] floatarray= Decimal[100];
    Binario[] boolarray=  Binario[100]; 
    Caracter[][] bibuffer=Caracter[10][10];
    Entero[][] biintarray=Entero[10][10];
    Decimal[][] bifloatarray=Decimal[10][10];
    Binario[][] biboolarray=Binario[10][10];
    Caracter[] hola= "Hola Mundo"; 
}
Codigo:
{
    #Mostrar("El valor anterior es => ");
    #Mostrar(int);
    #SaltoLinea();

    $int = (int*-1);

    #Mostrar("El nuevo valor es => ");
    #Mostrar(int);
    #SaltoLinea();
}



----------------------------------------------------------------------------------------




Global:
{
    Entero aa;
    Entero int=10;
    Entero eint=-10;
    Decimal float= 0.5;
    Decimal efloat=-0.5;
    Binario bool= Falso; 
    Caracter char= 'A';
    Caracter[] buffer= Caracter[100];
    Entero[] intarray = Entero[100];
    Decimal[] floatarray= Decimal[100];
    Binario[] boolarray=  Binario[100]; 
    Caracter[][] bibuffer=Caracter[10][10];
    Entero[][] biintarray=Entero[10][10];
    Decimal[][] bifloatarray=Decimal[10][10];
    Binario[][] biboolarray=Binario[10][10];
    Caracter[] hola= "Hola Mundo"; 
}
Codigo:
{
    Binario d= Falso;
    $d= (bool O Verdadero);
    #MostrarLn(d);
    Entero a= -2;
    #MostrarLn(a);
    Decimal b= -0.4;
    #MostrarLn(b);
    Caracter c= 'b';
    #MostrarLn(c);
}





_____________________________________________________________________

Global:
{
    Entero aa;
    Entero int=10;
    Entero eint=-10;
    Decimal float= 0.5;
    Decimal efloat=-0.5;
    Binario bool= Falso; 
    Caracter char= 'A';
    Caracter[] buffer= Caracter[100];
    Entero[] intarray = Entero[100];
    Decimal[] floatarray= Decimal[100];
    Binario[] boolarray=  Binario[100]; 
    Caracter[][] bibuffer=Caracter[10][10];
    Entero[][] biintarray=Entero[10][10];
    Decimal[][] bifloatarray=Decimal[10][10];
    Binario[][] biboolarray=Binario[10][10];
    Caracter[] hola= "Hola Mundo"; 
}

Funcion Nulo hola(Caracter[] hola_ss)
{
    #MostrarLn(hola_ss);
}

Codigo:
{
    Entero a= -2;
    #MostrarLn(a);
    Decimal b= -0.4;
    #MostrarLn(b);
    Caracter c= 'b';
    #MostrarLn(c);
    Binario d= Falso;
    #MostrarLn(d);
    #hola(hola);
}


__________________________________________________________________




Global:
{
    Entero aa;
    Entero int=10;
    Entero eint=-10;
    Decimal float= 0.5;
    Decimal efloat=-0.5;
    Binario bool= Falso; 
    Caracter char= 'A';
    Caracter[] buffer= Caracter[100];
    Entero[] intarray = Entero[100];
    Decimal[] floatarray= Decimal[100];
    Binario[] boolarray=  Binario[100]; 
    Caracter[][] bibuffer=Caracter[10][10];
    Entero[][] biintarray=Entero[10][10];
    Decimal[][] bifloatarray=Decimal[10][10];
    Binario[][] biboolarray=Binario[10][10];
    Caracter[] hola= "Hola Mundo"; 
}

Funcion Entero hola(Caracter[] hola_ss)
{
    Entero a= 0;
    Retorna a;
    #MostrarLn(hola_ss);
}

Codigo:
{
    Entero a= -2;
    #MostrarLn(a);
    Decimal b= -0.4;
    #MostrarLn(b);
    Caracter c= 'b';
    #MostrarLn(c);
    Binario d= Falso;
    #MostrarLn(d);
    #hola(hola);
}


__________________________________________________________


Global:
{
    Entero aa;
    Entero int=10;
    Entero eint=-10;
    Decimal float= 0.5;
    Decimal efloat=-0.5;
    Binario bool= Falso; 
    Caracter char= 'A';
    Caracter[] buffer= Caracter[100];
    Entero[] intarray = Entero[100];
    Decimal[] floatarray= Decimal[100];
    Binario[] boolarray=  Binario[100]; 
    Caracter[][] bibuffer=Caracter[10][10];
    Entero[][] biintarray=Entero[10][10];
    Decimal[][] bifloatarray=Decimal[10][10];
    Binario[][] biboolarray=Binario[10][10];
    Caracter[] hola= "Hola Mundo"; 
}
Funcion Binario ff(Binario[][] mat)
{
	$mat[2][2]= (bool O Verdadero);
	Retorna mat[2][2];
}
Codigo:
{
    Binario d= Falso;
    $d= (bool O Verdadero);
    #MostrarLn(d);
    Entero a= -2;
    #MostrarLn(a);
    Decimal b= -0.4;
    #MostrarLn(b);
    Caracter c= 'b';
    #MostrarLn(c);
	$bool= #ff(biboolarray);
    #Mostrar("El valor del return es: ");
    #MostrarLn(bool);
}


------------------------------------------------------------------------------

Global:
{
    Entero aa;
    Entero int=10;
    Entero eint=-10;
    Decimal float= 0.5;
    Decimal efloat=-0.5;
    Binario bool= Falso; 
    Caracter char= 'A';
    Caracter[] buffer= Caracter[100];
    Entero[] intarray = Entero[100];
    Decimal[] floatarray= Decimal[100];
    Binario[] boolarray=  Binario[100]; 
    Caracter[][] bibuffer=Caracter[10][10];
    Entero[][] biintarray=Entero[10][10];
    Decimal[][] bifloatarray=Decimal[10][10];
    Binario[][] biboolarray=Binario[10][10];
    Caracter[] hola= "Hola Mundo"; 
}




Codigo:
{
    Si(Verdadero) Hace
    {
        #MostrarLn("Hola desde if 1");
    }
}






-------------------------------------------------------------


Global:
{
    Entero aa;
    Entero int=10;
    Entero eint=-10;
    Decimal float= 0.5;
    Decimal efloat=-0.5;
    Binario bool= Falso; 
    Caracter char= 'A';
    Caracter[] buffer= Caracter[100];
    Entero[] intarray = Entero[100];
    Decimal[] floatarray= Decimal[100];
    Binario[] boolarray=  Binario[100]; 
    Caracter[][] bibuffer=Caracter[10][10];
    Entero[][] biintarray=Entero[10][10];
    Decimal[][] bifloatarray=Decimal[10][10];
    Binario[][] biboolarray=Binario[10][10];
    Caracter[] hola= "Hola Mundo"; 
}




Codigo:
{
	Binario a= Verdadero;
	Binario b= Verdadero;
    Si((a Y b)) Hace
    {
        #MostrarLn("Hola desde if 1");
    }
    Sino 
    {
        #MostrarLn("Hola desde Sino 1");
    }
}




____________________________________________________________________________

Global:
{
    Entero aa;
    Entero int=10;
    Entero eint=-10;
    Decimal float= 0.5;
    Decimal efloat=-0.5;
    Binario bool= Falso; 
    Caracter char= 'A';
    Caracter[] buffer= Caracter[100];
    Entero[] intarray = Entero[100];
    Decimal[] floatarray= Decimal[100];
    Binario[] boolarray=  Binario[100]; 
    Caracter[][] bibuffer=Caracter[10][10];
    Entero[][] biintarray=Entero[10][10];
    Decimal[][] bifloatarray=Decimal[10][10];
    Binario[][] biboolarray=Binario[10][10];
    Caracter[] hola= "Hola Mundo"; 
}
Funcion Binario ff(Entero param, Binario bin)
{
    Binario b2;
    $b2= (param == 0);
	Si((No)(b2 Y bin)) Hace
    {
        Retorna Verdadero;
    }
    Sino
    {
        Retorna Falso;
    }
}
Funcion Binario getvalue()
{
    Retorna Falso;
}
Codigo:
{
    $bool= Verdadero;
    Si(bool) Hace
    {
        #MostrarLn("Hola desde if 1");
    }
    $bool= #getvalue();
    Si(bool) Hace
    {
        $bool= #ff(0, Verdadero);
    }
    #Mostrar("El valor de bool es: ");
    #MostrarLn(bool);

}


_____________________________________________________________________________________




Global:
{
    Entero aa;
    Entero int=10;
    Entero eint=-10;
    Decimal float= 0.5;
    Decimal efloat=-0.5;
    Binario bool= Falso; 
    Caracter char= 'A';
    Caracter[] buffer= Caracter[100];
    Entero[] intarray = Entero[100];
    Decimal[] floatarray= Decimal[100];
    Binario[] boolarray=  Binario[100]; 
    Caracter[][] bibuffer=Caracter[10][10];
    Entero[][] biintarray=Entero[10][10];
    Decimal[][] bifloatarray=Decimal[10][10];
    Binario[][] biboolarray=Binario[10][10];
    Caracter[] hola= "Hola Mundo"; 
}
Funcion Entero sum(Entero num, Entero cont)
{
    $bool= (cont==11);
    Si(bool) Hace
    {
        Retorna num;
    }
    Sino
    {
        $num=(cont+num);
        $cont=(cont+1);
        $int=#sum(num, cont);
        Retorna int;
    }
}
Codigo:
{
    Entero x= 0;
    $x=#sum(0, 1);
    #MostrarLn(x);
}


_______________________________________________________________________


Global:
{
    Entero eint=-10;
    Decimal float= 0.5;
    Binario bool= Falso; 
    Caracter char= 'A';
}
Codigo:
{
    Entero sum= 0;
    Entero cont=1;
    Mientras((cont<=10)) Hace
    {
        #MostrarLn(cont);
        Si((cont==5)) Hace
        {
            #Mostrar("Codigo finalizado en: ");
            #MostrarLn(cont);
            Sale;
        }
        $sum=(sum+cont);
        $cont= (cont+1);
    }
    #MostrarLn(sum);
}




--------------


i++; current_lexeme = lexemes[i];
                            DataField found_variable = null;
                            findVariable(ref found_variable, src_local_variables, current_lexeme.Text, true);
                            i++; current_lexeme = lexemes[i];
                            int column=0;
                            int row=0;
                            string index_ss = string.Empty;
                            for (int x = i; (lexemes[x].WhatKind == LexemeKind.Numeric || lexemes[x].WhatKind == LexemeKind.SquareBrackets); x++)
                            {
                                index_ss += lexemes[x].Text;
                            }
                            if (Regex.IsMatch(index_ss, "(\\[[0-9]+\\])(\\[[0-9]+\\])"))
                            {
                                if (!lexemes[i + 6].Text.Equals("=")) throw new Exception("Error de Sintaxis: Signo de asignacion despues de variable faltante");
                                row = int.Parse(lexemes[i + 1].Text);
                                column = int.Parse(lexemes[i + 4].Text);
                                try
                                {
                                    switch (found_variable.Type)
                                    {
                                        case DATA_TYPE.BIARRAY_BINARIO:
                                            {
                                                found_variable = ((NonPrimitiveMultiArray<bool>)found_variable).Values[row, column];
                                                break;
                                            }
                                        case DATA_TYPE.BIARRAY_CARACTER:
                                            {
                                                found_variable = ((NonPrimitiveMultiArray<char>)found_variable).Values[row, column];
                                                break;
                                            }
                                        case DATA_TYPE.BIARRAY_ENTERO:
                                            {
                                                found_variable = ((NonPrimitiveMultiArray<int>)found_variable).Values[row, column];
                                                break;
                                            }
                                        case DATA_TYPE.BIARRAY_DECIMAL:
                                            {
                                                found_variable = ((NonPrimitiveMultiArray<double>)found_variable).Values[row, column];
                                                break;
                                            }
                                        default:
                                            {
                                                throw new Exception("Error de Semantica: La variable " + found_variable.Identifier + " no posee indices dobles");
                                            }
                                    }
                                }
                                catch (IndexOutOfRangeException)
                                {
                                    throw new Exception("Error de Semantica: Los indices especificados para el arreglo bidimensional " + found_variable.Identifier + " son erroneos");
                                }
                                i += 7; current_lexeme = lexemes[i];
                            }
                            else if (Regex.IsMatch(index_ss, "(\\[[0-9]+\\])"))
                            {
                                if (!lexemes[i+3].Text.Equals("=")) throw new Exception("Error de Sintaxis: Signo de asignacion despues de variable faltante");
                                column = int.Parse(lexemes[i + 1].Text);
                                try
                                {
                                    switch (found_variable.Type)
                                    {
                                        case DATA_TYPE.ARRAY_BINARIO:
                                            {
                                                found_variable = ((NonPrimitiveArray<bool>)found_variable).Values[column];
                                                break;
                                            }
                                        case DATA_TYPE.ARRAY_CARACTER:
                                            {
                                                found_variable = ((NonPrimitiveArray<char>)found_variable).Values[column];
                                                break;
                                            }
                                        case DATA_TYPE.ARRAY_ENTERO:
                                            {
                                                found_variable = ((NonPrimitiveArray<int>)found_variable).Values[column];
                                                break;
                                            }
                                        case DATA_TYPE.ARRAY_DECIMAL:
                                            {
                                                found_variable = ((NonPrimitiveArray<double>)found_variable).Values[column];
                                                break;
                                            }
                                        default:
                                            {
                                                throw new Exception("Error de Semantica: La variable " + found_variable.Identifier + " no posee indices");
                                            }
                                    }
                                }
                                catch(IndexOutOfRangeException)
                                {
                                    throw new Exception("Error de Semantica: Los indices especificados para el arreglo " + found_variable.Identifier + " son erroneos");
                                }
                                i +=4; current_lexeme = lexemes[i];
                            }
                            else
                            {
                                if (!current_lexeme.Text.Equals("=")) throw new Exception("Error de Sintaxis: Signo de asignacion despues de variable faltante");
                                i++; current_lexeme = lexemes[i];
                            }
                            string value= string.Empty;
                            int negative=1;
                            bool not = false;
                            if (current_lexeme.Text.Equals("-"))
                            {
                                negative = -1;
                                i++; current_lexeme = lexemes[i];
                            }
                            else if (current_lexeme.Text.Equals("(No)"))
                            {
                                not = true;
                                i++; current_lexeme = lexemes[i];
                            }
                            if (current_lexeme.Text.Equals("(")) //ENCONTRAR ASIGNACION DE OPERACION INICIA
                            {
                                if (negative==-1) throw new Exception("Error de Sintaxis: No se puede usar signo negativo para efectuar una operacion, solo el operador logico (No)");
                                i++; current_lexeme = lexemes[i];
                                if (current_lexeme.Text.Equals("-")) //PODRIA SER NEGATIVO
                                {
                                    negative = -1;
                                    i++; current_lexeme = lexemes[i];
                                }
                                DataField operand1 = getVariableValueFromLexeme(lexemes,ref i, src_local_variables); //OPERANDO IZQUIERDO
                                if (negative == -1 && !operand1.Identifier.Equals("000")) throw new Exception("Error de Sintaxis: Solo las constantes pueden tener signo, las variables no");
                                i++; current_lexeme = lexemes[i];
                                string operator_ss= current_lexeme.Text;
                                switch(current_lexeme.WhatKind)
                                {
                                    case LexemeKind.ArithmeticOperator:
                                        {
                                            if (!(found_variable.Type == DATA_TYPE.ENTERO || found_variable.Type == DATA_TYPE.DECIMAL)) throw new Exception("Una operacion aritmetica solo puede asignarse a una variable Entera o Decimal");
                                            i++; current_lexeme = lexemes[i];
                                            int negative2 = 1;
                                            if (current_lexeme.Text.Equals("-")) //PODRIA SER NEGATIVO
                                            {
                                                negative2 = -1;
                                                i++; current_lexeme = lexemes[i];
                                            }
                                            DataField operand2 = getVariableValueFromLexeme(lexemes, ref i, src_local_variables); //OPERANDO DERECHO
                                            if (negative2 == -1 && !operand2.Identifier.Equals("000")) throw new Exception("Error de Sintaxis: Solo las constantes pueden tener signo, las variables no");
                                            i++; current_lexeme = lexemes[i];
                                            if (current_lexeme.Text.Equals(")")) //FINAL DE LA OPERACION, SE REVISA SINTAXIS Y SEMANTICA
                                            {
                                                if (!((operand1.Type == DATA_TYPE.ENTERO || operand1.Type == DATA_TYPE.DECIMAL) && (operand2.Type == DATA_TYPE.ENTERO || operand2.Type == DATA_TYPE.DECIMAL))) throw new Exception("Error de Sintaxis: En una operacion aritmerica los operando solo pueden ser Entero o Decimal");
                                                if(operand1.Type==DATA_TYPE.ENTERO && operand2.Type == DATA_TYPE.DECIMAL)
                                                {
                                                    ((PrimitiveVariable<int>)operand1).Value *= negative;//permite cambiar el signo del valor si es necesario
                                                    ((PrimitiveVariable<double>)operand2).Value *= negative2;
                                                    dest_code.Add(new StructValueAssignOperation(found_variable, new StructArithmeticOperation((PrimitiveVariable<int>)operand1, (PrimitiveVariable<double>)operand2, operator_ss, found_variable.Type)));
                                                }
                                                else if (operand1.Type == DATA_TYPE.DECIMAL && operand2.Type == DATA_TYPE.ENTERO)
                                                {
                                                    ((PrimitiveVariable<double>)operand1).Value *= negative;
                                                    ((PrimitiveVariable<int>)operand2).Value *= negative2;
                                                    dest_code.Add(new StructValueAssignOperation(found_variable, new StructArithmeticOperation((PrimitiveVariable<double>)operand1, (PrimitiveVariable<int>)operand2, operator_ss, found_variable.Type)));
                                                }
                                                else if (operand1.Type == DATA_TYPE.DECIMAL && operand2.Type == DATA_TYPE.DECIMAL)
                                                {
                                                    ((PrimitiveVariable<double>)operand1).Value *= negative;
                                                    ((PrimitiveVariable<double>)operand2).Value *= negative2;
                                                    dest_code.Add(new StructValueAssignOperation(found_variable, new StructArithmeticOperation((PrimitiveVariable<double>)operand1, (PrimitiveVariable<double>)operand2, operator_ss, found_variable.Type)));
                                                }
                                                else if (operand1.Type == DATA_TYPE.ENTERO && operand2.Type == DATA_TYPE.ENTERO)
                                                {
                                                    ((PrimitiveVariable<int>)operand1).Value *= negative;
                                                    ((PrimitiveVariable<int>)operand2).Value *= negative2;
                                                    dest_code.Add(new StructValueAssignOperation(found_variable, new StructArithmeticOperation((PrimitiveVariable<int>)operand1, (PrimitiveVariable<int>)operand2, operator_ss, found_variable.Type)));
                                                }
                                            }
                                            else
                                            {
                                                throw new Exception("Error de Sintaxis: Las operaciones deben finalizar con )");
                                            }
                                            break;
                                        }
                                    case LexemeKind.LogicOperator:
                                        {
                                            if (found_variable.Type != DATA_TYPE.BINARIO) throw new Exception("Una operacion logica solo puede ser asignada a una variable Binaria");
                                            i++; current_lexeme = lexemes[i];
                                            DataField operand2 = getVariableValueFromLexeme(lexemes, ref i, src_local_variables); //OPERANDO DERECHO
                                            i++; current_lexeme = lexemes[i];
                                            if (current_lexeme.Text.Equals(")")) //FINAL DE LA OPERACION, SE REVISA SINTAXIS Y SEMANTICA
                                            {
                                                if (!(operand1.Type == DATA_TYPE.BINARIO && operand2.Type==DATA_TYPE.BINARIO)) throw new Exception("Error de Sintaxis: En una operacion logica los operando solo pueden ser Binario");
                                                dest_code.Add(new StructValueAssignOperation(found_variable, new StructLogicOperation((PrimitiveVariable<bool>) operand1,(PrimitiveVariable<bool>) operand2, operator_ss, not)));
                                            }
                                            else
                                            {
                                                throw new Exception("Error de Sintaxis: Las operaciones deben finalizar con )");
                                            }
                                            break;
                                        }
                                    case LexemeKind.CompareOperator: //
                                        {
                                            if (found_variable.Type != DATA_TYPE.BINARIO) throw new Exception("Una operacion comparativa solo puede ser asignada a una variable Binaria");
                                            i++; current_lexeme = lexemes[i];
                                            int negative2 = 1;
                                            if (current_lexeme.Text.Equals("-")) //PODRIA SER NEGATIVO
                                            {
                                                negative2 = -1;
                                                i++; current_lexeme = lexemes[i];
                                            }
                                            DataField operand2 = getVariableValueFromLexeme(lexemes, ref i, src_local_variables); //OPERANDO DERECHO
                                            i++; current_lexeme = lexemes[i];
                                            if (current_lexeme.Text.Equals(")")) //FINAL DE LA OPERACION, SE REVISA SINTAXIS Y SEMANTICA
                                            {
                                                if (!((operand1.Type == DATA_TYPE.ENTERO || operand1.Type == DATA_TYPE.DECIMAL) && (operand2.Type == DATA_TYPE.ENTERO || operand2.Type == DATA_TYPE.DECIMAL))) throw new Exception("Error de Sintaxis: En una operacion aritmerica los operando solo pueden ser Entero o Decimal");
                                                if (operand1.Type == DATA_TYPE.ENTERO && operand2.Type == DATA_TYPE.DECIMAL)
                                                {
                                                    ((PrimitiveVariable<int>)operand1).Value *= negative;//permite cambiar el signo del valor si es necesario
                                                    ((PrimitiveVariable<double>)operand2).Value *= negative2;
                                                    dest_code.Add(new StructValueAssignOperation(found_variable, new StructCompareOperation((PrimitiveVariable<int>)operand1, (PrimitiveVariable<double>)operand2, operator_ss)));
                                                }
                                                else if (operand1.Type == DATA_TYPE.DECIMAL && operand2.Type == DATA_TYPE.ENTERO)
                                                {
                                                    ((PrimitiveVariable<double>)operand1).Value *= negative;
                                                    ((PrimitiveVariable<int>)operand2).Value *= negative2;
                                                    dest_code.Add(new StructValueAssignOperation(found_variable, new StructCompareOperation((PrimitiveVariable<double>)operand1, (PrimitiveVariable<int>)operand2, operator_ss)));
                                                }
                                                else if (operand1.Type == DATA_TYPE.DECIMAL && operand2.Type == DATA_TYPE.DECIMAL)
                                                {
                                                    ((PrimitiveVariable<double>)operand1).Value *= negative;
                                                    ((PrimitiveVariable<double>)operand2).Value *= negative2;
                                                    dest_code.Add(new StructValueAssignOperation(found_variable, new StructCompareOperation((PrimitiveVariable<double>)operand1, (PrimitiveVariable<double>)operand2, operator_ss)));
                                                }
                                                else if (operand1.Type == DATA_TYPE.ENTERO && operand2.Type == DATA_TYPE.ENTERO)
                                                {
                                                    ((PrimitiveVariable<int>)operand1).Value *= negative;
                                                    ((PrimitiveVariable<int>)operand2).Value *= negative2;
                                                    dest_code.Add(new StructValueAssignOperation(found_variable, new StructCompareOperation((PrimitiveVariable<int>)operand1, (PrimitiveVariable<int>)operand2, operator_ss)));
                                                }
                                            }
                                            else
                                            {
                                                throw new Exception("Error de Sintaxis: Las operaciones deben finalizar con )");
                                            }
                                            break;
                                        }
                                    default:
                                        {
                                            throw new Exception("Error de Sintaxis: La operacion no tiene un formato correcto");
                                        }
                                } //ENCONTRAR ASIGNACION DE OPERACION TERMINA
                                i++; current_lexeme = lexemes[i];
                                if (current_lexeme.Text.Equals(";"))
                                {
                                    i++; current_lexeme = lexemes[i];
                                    continue;
                                }
                                else
                                {
                                    throw new Exception("Error de Sintaxis: Los finales de linea deben acabar con ;");
                                }

                            }
                            else
                            {
                                value += current_lexeme.Text;
                                switch(current_lexeme.WhatKind)
                                {
                                    case LexemeKind.String:
                                        {
                                            if(negative==-1) throw new Exception("Error de Sintaxis: El signo de negativo no se permite con arreglos de caracteres");
                                            if (found_variable.Type == DATA_TYPE.ARRAY_CARACTER)
                                            {
                                                i++; current_lexeme = lexemes[i];
                                                if(current_lexeme.Text.Equals(";"))
                                                {
                                                    dest_code.Add(new StructValueAssign(found_variable, new NonPrimitiveArray<char>(value.Length - 2, value.Replace("\"", string.Empty).ToArray(), DATA_TYPE.ARRAY_CARACTER, "000")));
                                                }
                                                else
                                                {
                                                    throw new Exception("Error de Sintaxis: Final de linea invalido, talves haga falta un ;");
                                                }
                                                i++; current_lexeme = lexemes[i];
                                            }
                                            else
                                            {
                                                throw new Exception("Error de Semantica: Los tipos de dato no coinciden");
                                            }
                                            break;
                                        }
                                    case LexemeKind.Numeric:
                                        {
                                            if (negative==-1) value= "-" + value;
                                            if (found_variable.Type == DATA_TYPE.ENTERO)
                                            {
                                                i++; current_lexeme = lexemes[i];
                                                if (current_lexeme.Text.Equals(";"))
                                                {
                                                    int val = 0;
                                                    if(int.TryParse(value, out val))
                                                    {
                                                        dest_code.Add(new StructValueAssign(found_variable, new PrimitiveVariable<int>(val, "000", DATA_TYPE.ENTERO)));
                                                    }
                                                    else
                                                    {
                                                        throw new Exception("Error de Sintaxis: No se pudo leer el formato del numero.");
                                                    }
                                                }
                                                else
                                                {
                                                    throw new Exception("Error de Sintaxis: Final de linea invalido, talves haga falta un ; o el valor este mal escrito.");
                                                }
                                                i++; current_lexeme = lexemes[i];
                                            }
                                            else if (found_variable.Type == DATA_TYPE.DECIMAL)
                                            {
                                                i++; current_lexeme = lexemes[i];
                                                if (current_lexeme.Text.Equals(";"))
                                                {
                                                    double val = 0;
                                                    if (double.TryParse(value, out val))
                                                    {
                                                        dest_code.Add(new StructValueAssign(found_variable, new PrimitiveVariable<double>(val, "000", DATA_TYPE.DECIMAL)));
                                                    }
                                                    else
                                                    {
                                                        throw new Exception("Error de Sintaxis: No se pudo leer el formato del numero.");
                                                    }
                                                }
                                                else
                                                {
                                                    throw new Exception("Error de Sintaxis: Final de linea invalido, talves haga falta un ;");
                                                }
                                                i++; current_lexeme = lexemes[i];
                                            }
                                            else
                                            {
                                                throw new Exception("Error de Semantica: Los tipos de dato no coinciden");
                                            }
                                            break;
                                        }
                                    case LexemeKind.BooleanValue:
                                        {
                                            if (negative==-1) throw new Exception("Error de Sintaxis: El valor de asignacion no se permite con valores Binario");
                                            if (found_variable.Type == DATA_TYPE.BINARIO)
                                            {
                                                i++; current_lexeme = lexemes[i];
                                                if (current_lexeme.Text.Equals(";"))
                                                {
                                                    dest_code.Add(new StructValueAssign(found_variable, new PrimitiveVariable<bool>(value.Equals("Verdadero"), "000", DATA_TYPE.BINARIO)));
                                                }
                                                else
                                                {
                                                    throw new Exception("Error de Sintaxis: Final de linea invalido, talves haga falta un ;");
                                                }
                                                i++; current_lexeme = lexemes[i];
                                            }
                                            else
                                            {
                                                throw new Exception("Error de Semantica: Los tipos de dato no coinciden");
                                            }
                                            break;
                                        }
                                    case LexemeKind.Identifier:
                                        {
                                            if (negative == -1) throw new Exception("Error de Sintaxis: El valor de asignacion negativo para variables no es posible en valores que no sean operaciones");
                                            DataField found_variable_value = null;
                                            findVariable(ref found_variable_value, src_local_variables, current_lexeme.Text, true);
                                            if (found_variable_value.Type == found_variable.Type)
                                            {
                                                i++; current_lexeme = lexemes[i];
                                                if (current_lexeme.Text.Equals(";"))
                                                {
                                                    dest_code.Add(new StructValueAssign(found_variable, found_variable_value));
                                                }
                                                else
                                                {
                                                    throw new Exception("Error de Sintaxis: Final de linea invalido, talves haga falta un ;");
                                                }
                                                i++; current_lexeme = lexemes[i];
                                            }
                                            else
                                            {
                                                throw new Exception("Error de Semantica: Los tipos de dato no coinciden");
                                            }
                                            break;
                                        }
                                    case LexemeKind.Char:
                                        {
                                            if (negative == -1) throw new Exception("Error de Sintaxis: El valor de asignacion no es reconocible");
                                            if (found_variable.Type == DATA_TYPE.CARACTER)
                                            {
                                                i++; current_lexeme = lexemes[i];
                                                if (current_lexeme.Text.Equals(";"))
                                                {
                                                    dest_code.Add(new StructValueAssign(found_variable, new PrimitiveVariable<char>(char.Parse(value.Replace("'", string.Empty)), "000", DATA_TYPE.CARACTER)));
                                                }
                                                else
                                                {
                                                    throw new Exception("Error de Sintaxis: Final de linea invalido, talves haga falta un ;");
                                                }
                                            }
                                            else
                                            {
                                                throw new Exception("Error de Semantica: Los tipos de dato no coinciden");
                                            }
                                            i++; current_lexeme = lexemes[i];
                                            break;
                                        }
                                    case LexemeKind.KeyCharacter:
                                        {
                                            if (!current_lexeme.Text.Equals("#")) throw new Exception("Error de Compilacion: No se logro desifrar el valor de asignacion a la variable " + found_variable.Identifier); 
                                            if (negative == -1) throw new Exception("Error de Compilacion: Una llamada a funcion no puede tener signo negativo");
                                            i++; current_lexeme = lexemes[i];
                                            if (current_lexeme.WhatKind != LexemeKind.Identifier) throw new Exception("Error de Compilacion: No se pudo comprender el identificador de la funcion despues de \"#\"");
                                            
                                            string func_name = current_lexeme.Text;
                                            i++; current_lexeme = lexemes[i];
                                            if (!current_lexeme.Text.Equals("(")) throw new Exception("Error de Sintaxis: Los parametros de la funcion inician con (");
                                            i++; current_lexeme = lexemes[i];
                                            List<DataField> data_params = new List<DataField>();
                                            while (!current_lexeme.Text.Equals(")"))
                                            {
                                                data_params.Add(getVariableValueFromLexeme(lexemes, ref i, src_local_variables));
                                                i++; current_lexeme = lexemes[i];
                                                if (current_lexeme.Text.Equals(","))
                                                {
                                                    i++; current_lexeme = lexemes[i];
                                                }
                                            }
                                            i++; current_lexeme = lexemes[i];
                                            if (!current_lexeme.Text.Equals(";")) throw new Exception("Error de Sintaxis: Final de Linea invalido.");
                                            List<DATA_TYPE> types_params = new List<DATA_TYPE>();
                                            foreach (var item in data_params)
                                            {
                                                types_params.Add(item.Type);
                                            }
                                            StructFuncion aux = findFuncion(func_name, types_params);
                                            if (aux == null) throw new Exception("Error de Semantica: La funcion llamada " + func_name + " no existe o ninguna de sus sobrecargas corresponde con los parametros ingresados");
                                            if (found_variable.Type != aux.ReturnType) throw new Exception("Error de Semantica: El tipo de dato devuelto por " + func_name + " " + DataField.DataTypeToString(aux.ReturnType) + " no es el mismo de la variable " + found_variable.Identifier + " " + DataField.DataTypeToString(found_variable.Type));
                                            dest_code.Add(new StructValueAssignCall(found_variable, new StructFuncionCall(aux, data_params)));
                                            i++; current_lexeme = lexemes[i];
                                            break;
                                        }
                                    default:
                                        {
                                            throw new Exception("Error de Sintaxis: El valor de asignacion no es reconocible");
                                        }
                                }
                            }